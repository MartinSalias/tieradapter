Lparameters toException

LOCAL loError AS Object

loError = toException
DO WHILE loError.ErrorNo = 2071 && User Thrown Error
	IF VARTYPE( loError.UserValue ) = "O"
		loError = loError.UserValue 
	ELSE
		EXIT
	ENDIF
ENDDO

#include ..\comun\ms.h

DO CASE

	Case Between(loError.ErrorNo,9990,9999)	 && Error generated by the user.
		Return Alltrim( loError.Message ) + CR ;
			 + Alltrim( loError.Details )
		
	Case loError.ErrorNo = 1884	 && The uniqueness of primary or candidate key is violated.

		Local lcField As String 
		lcField = ALLTRIM( loError.Details )
		Return CR ;
			+ "Ha intentado ingresar un valor ya existente" + CR ;
			+ "en " + UPPER( RIGHT( lcField, LEN( lcField ) ) ) + "." + CR ;
			+ CR + "Los datos no han sido guardados."


	Case [Microsoft OLE DB Provider for SQL Server : Cannot insert duplicate key row in object] $ loError.Message ;
	     And [with unique index] $ loError.Message
	     
		Local lnBegin As Integer, lnEnd As Integer, lcTable As String
		lnBegin = Atc( ['], loError.Details, 1 ) + 1
		lnEnd = Atc( ['], loError.Details, 2 )
		lcTable = Substr( loError.Details, lnBegin, lnEnd - lnBegin )
		Return CR ;
			+ "Ha intentado ingresar un valor ya existente" + CR ;
			+ "en la tabla " + UPPER( lcTable ) + "." + CR ;
			+ CR + "Los datos no han sido guardados."	     

	Case [Multiple-step operation generated error] $ loError.Message

		Return CR ;
			+ [MULTIPLE-STEP OPERATION GENERATED ERROR] + CR + CR ;
			+ [This error means that one or more fields you are inserting/updating] + CR ;
			+ [contain an invalid value. Some of the possible scenarios are:] + CR + CR  ;
			+ [1. A string value is being inserted into a numeric field.] + CR ; 
			+ [2. An invalid date expression is being inserted into a date field.] + CR ; 
			+ [3. A string value being inserted is longer than the size of the string field.] + CR ;
			+ [4. A null value is being inserted into a field that does not allow nulls.]

	Otherwise 

		Local i As Integer, lcStack As String 
		lcStack = []
		For i = 1 To Program(-1)-1
			lcStack = lcStack + Proper(Program(i)) + [; ]
		Next
		
		Return CR ;
		+ [Error: ]			+ ALLTRIM( Transform(loError.ErrorNo) ) + CR ;
		+ [Message: ]		+ ALLTRIM( loError.Message ) + CR ;
		+ [Procedure: ]		+ ALLTRIM( loError.Procedure ) + CR ;
		+ [LineNo: ]		+ ALLTRIM( Transform( loError.LineNo) ) + CR ; 
		+ [Details: ]		+ ALLTRIM( loError.Details ) + CR ;
		+ [StackLevel: ]	+ ALLTRIM( Transform(loError.StackLevel) ) + CR ;
		+ [StackContent: ]	+ lcStack + CR ;
		+ [LineContents: ]	+ ALLTRIM( loError.LineContents ) && + CR ;
		+ [UserValue: ]		+ toException.UserValue

EndCase
